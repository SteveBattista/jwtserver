use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use std::collections::HashMap;
use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;

/// JWT Server User Management Tool
/// 
/// Manages users in the users.txt file with Argon2id password hashing
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Path to the users.txt file
    #[arg(short, long, default_value = "../users.txt")]
    file: String,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Add a new user
    Add {
        /// Username to add
        username: String,
        /// Password for the user
        password: String,
    },
    /// Remove an existing user
    Remove {
        /// Username to remove
        username: String,
    },
    /// Update password for existing user
    Update {
        /// Username to update
        username: String,
        /// New password
        password: String,
    },
    /// List all users
    List,
    /// Verify a user's password
    Verify {
        /// Username to verify
        username: String,
        /// Password to check
        password: String,
    },
}

/// Loads user data from the users.txt file.
/// 
/// # Arguments
/// * `file_path` - Path to the users.txt file
/// 
/// # Returns
/// * `Result<HashMap<String, String>>` - Map of usernames to password hashes
fn load_users(file_path: &str) -> Result<HashMap<String, String>> {
    if !Path::new(file_path).exists() {
        return Ok(HashMap::new());
    }

    let file = File::open(file_path)
        .with_context(|| format!("Failed to open users file: {}", file_path))?;
    
    let reader = BufReader::new(file);
    let mut users = HashMap::new();
    
    for (line_num, line) in reader.lines().enumerate() {
        let line = line.with_context(|| format!("Failed to read line {} from {}", line_num + 1, file_path))?;
        
        if line.trim().is_empty() || line.starts_with('#') {
            continue; // Skip empty lines and comments
        }
        
        if let Some((username, hash)) = line.split_once(':') {
            users.insert(username.trim().to_string(), hash.trim().to_string());
        } else {
            eprintln!("Warning: Skipping malformed line {}: {}", line_num + 1, line);
        }
    }
    
    Ok(users)
}

/// Saves user data to the users.txt file.
/// 
/// # Arguments
/// * `file_path` - Path to the users.txt file
/// * `users` - Map of usernames to password hashes
/// 
/// # Returns
/// * `Result<()>` - Success or error
fn save_users(file_path: &str, users: &HashMap<String, String>) -> Result<()> {
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(file_path)
        .with_context(|| format!("Failed to create/open users file: {}", file_path))?;

    // Write header comment
    writeln!(file, "# JWT Server Users File")?;
    writeln!(file, "# Format: username:argon2id_hash")?;
    writeln!(file, "# Generated by user_manager tool")?;
    writeln!(file)?;

    // Sort usernames for consistent output
    let mut sorted_users: Vec<_> = users.iter().collect();
    sorted_users.sort_by_key(|(username, _)| *username);

    for (username, hash) in sorted_users {
        writeln!(file, "{}:{}", username, hash)?;
    }

    Ok(())
}

/// Hashes a password using Argon2id.
/// 
/// # Arguments
/// * `password` - Plain text password to hash
/// 
/// # Returns
/// * `Result<String>` - Argon2id hash string
fn hash_password(password: &str) -> Result<String> {
    use rand::rngs::OsRng;
    let argon2 = Argon2::default();
    let salt = argon2::password_hash::SaltString::generate(&mut OsRng);
    
    let password_hash = argon2
        .hash_password(password.as_bytes(), &salt)
        .map_err(|e| anyhow::anyhow!("Failed to hash password: {}", e))?;
    
    Ok(password_hash.to_string())
}

/// Verifies a password against an Argon2id hash.
/// 
/// # Arguments
/// * `password` - Plain text password to verify
/// * `hash` - Argon2id hash to verify against
/// 
/// # Returns
/// * `Result<bool>` - True if password matches, false otherwise
fn verify_password(password: &str, hash: &str) -> Result<bool> {
    let parsed_hash = PasswordHash::new(hash)
        .map_err(|e| anyhow::anyhow!("Failed to parse password hash: {}", e))?;
    
    let argon2 = Argon2::default();
    Ok(argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
}

/// Adds a new user to the users file.
/// 
/// # Arguments
/// * `file_path` - Path to users.txt
/// * `username` - Username to add
/// * `password` - Password to hash and store
/// 
/// # Returns
/// * `Result<()>` - Success or error
fn add_user(file_path: &str, username: &str, password: &str) -> Result<()> {
    let mut users = load_users(file_path)?;
    
    if users.contains_key(username) {
        anyhow::bail!("User '{}' already exists. Use 'update' to change password.", username);
    }
    
    let hash = hash_password(password)?;
    users.insert(username.to_string(), hash);
    
    save_users(file_path, &users)?;
    println!("✅ Added user '{}'", username);
    
    Ok(())
}

/// Removes a user from the users file.
/// 
/// # Arguments
/// * `file_path` - Path to users.txt
/// * `username` - Username to remove
/// 
/// # Returns
/// * `Result<()>` - Success or error
fn remove_user(file_path: &str, username: &str) -> Result<()> {
    let mut users = load_users(file_path)?;
    
    if users.remove(username).is_none() {
        anyhow::bail!("User '{}' not found", username);
    }
    
    save_users(file_path, &users)?;
    println!("✅ Removed user '{}'", username);
    
    Ok(())
}

/// Updates a user's password in the users file.
/// 
/// # Arguments
/// * `file_path` - Path to users.txt
/// * `username` - Username to update
/// * `password` - New password to hash and store
/// 
/// # Returns
/// * `Result<()>` - Success or error
fn update_user(file_path: &str, username: &str, password: &str) -> Result<()> {
    let mut users = load_users(file_path)?;
    
    if !users.contains_key(username) {
        anyhow::bail!("User '{}' not found. Use 'add' to create new user.", username);
    }
    
    let hash = hash_password(password)?;
    users.insert(username.to_string(), hash);
    
    save_users(file_path, &users)?;
    println!("✅ Updated password for user '{}'", username);
    
    Ok(())
}

/// Lists all users in the users file.
/// 
/// # Arguments
/// * `file_path` - Path to users.txt
/// 
/// # Returns
/// * `Result<()>` - Success or error
fn list_users(file_path: &str) -> Result<()> {
    let users = load_users(file_path)?;
    
    if users.is_empty() {
        println!("No users found in {}", file_path);
        return Ok(());
    }
    
    println!("Users in {}:", file_path);
    println!("┌─────────────────┬──────────────────────────────────────────────┐");
    println!("│ Username        │ Password Hash (first 40 chars)              │");
    println!("├─────────────────┼──────────────────────────────────────────────┤");
    
    let mut sorted_users: Vec<_> = users.iter().collect();
    sorted_users.sort_by_key(|(username, _)| *username);
    
    for (username, hash) in sorted_users {
        let hash_preview = if hash.len() > 40 {
            format!("{}...", &hash[..40])
        } else {
            hash.clone()
        };
        println!("│ {:<15} │ {:<44} │", username, hash_preview);
    }
    
    println!("└─────────────────┴──────────────────────────────────────────────┘");
    println!("Total users: {}", users.len());
    
    Ok(())
}

/// Verifies a user's password.
/// 
/// # Arguments
/// * `file_path` - Path to users.txt
/// * `username` - Username to verify
/// * `password` - Password to check
/// 
/// # Returns
/// * `Result<()>` - Success or error
fn verify_user(file_path: &str, username: &str, password: &str) -> Result<()> {
    let users = load_users(file_path)?;
    
    let Some(hash) = users.get(username) else {
        anyhow::bail!("User '{}' not found", username);
    };
    
    if verify_password(password, hash)? {
        println!("✅ Password correct for user '{}'", username);
    } else {
        println!("❌ Password incorrect for user '{}'", username);
    }
    
    Ok(())
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    match cli.command {
        Commands::Add { username, password } => {
            add_user(&cli.file, &username, &password)?;
        }
        Commands::Remove { username } => {
            remove_user(&cli.file, &username)?;
        }
        Commands::Update { username, password } => {
            update_user(&cli.file, &username, &password)?;
        }
        Commands::List => {
            list_users(&cli.file)?;
        }
        Commands::Verify { username, password } => {
            verify_user(&cli.file, &username, &password)?;
        }
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::NamedTempFile;

    #[test]
    fn test_password_hashing_and_verification() {
        let password = "test_password_123";
        let hash = hash_password(password).unwrap();
        
        assert!(verify_password(password, &hash).unwrap());
        assert!(!verify_password("wrong_password", &hash).unwrap());
    }

    #[test]
    fn test_user_operations() {
        let temp_file = NamedTempFile::new().unwrap();
        let file_path = temp_file.path().to_str().unwrap();

        // Add user
        add_user(file_path, "testuser", "testpass").unwrap();
        
        // Verify user exists
        let users = load_users(file_path).unwrap();
        assert!(users.contains_key("testuser"));
        
        // Update user
        update_user(file_path, "testuser", "newpass").unwrap();
        
        // Verify password
        verify_user(file_path, "testuser", "newpass").unwrap();
        
        // Remove user
        remove_user(file_path, "testuser").unwrap();
        
        // Verify user removed
        let users = load_users(file_path).unwrap();
        assert!(!users.contains_key("testuser"));
    }
}
